<!--
### Блок
#### Описание
#### Причины использования
#### Примеры
-->

# Гайд по стилю SQL-запросов



<!-- markdown="1" необходим для страниц GitHub, что корректно отображать TOC. -->

* [Предисловие](#%D0%BF%D1%80%D0%B5%D0%B4%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5)
* [Основные положения](#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
  * [Хороший стиль](#%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B9-%D1%81%D1%82%D0%B8%D0%BB%D1%8C)
  * [Плохой стиль](#%D0%BF%D0%BB%D0%BE%D1%85%D0%BE%D0%B9-%D1%81%D1%82%D0%B8%D0%BB%D1%8C)
* [Соглашения о наименовании](#%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE-%D0%BD%D0%B0%D0%B8%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8)
  * [Общее](#%D0%BE%D0%B1%D1%89%D0%B5%D0%B5)
  * [Таблицы](#%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B)
  * [Столбцы](#%D1%81%D1%82%D0%BE%D0%BB%D0%B1%D1%86%D1%8B)
  * [Псевдонимы/корреляции](#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC%D1%8B%D0%BA%D0%BE%D1%80%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%B8)
  * [Хранимые процедуры](#%D1%85%D1%80%D0%B0%D0%BD%D0%B8%D0%BC%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B)
  * [Универсальные суффиксы](#%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D1%83%D1%84%D1%84%D0%B8%D0%BA%D1%81%D1%8B)
* [Синтаксис запросов](#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2)
  * [Зарезервированные слова](#%D0%B7%D0%B0%D1%80%D0%B5%D0%B7%D0%B5%D1%80%D0%B2%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0)
  * [Пробельные символы](#%D0%BF%D1%80%D0%BE%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8B)
  * [Отступы](#%D0%BE%D1%82%D1%81%D1%82%D1%83%D0%BF%D1%8B)
  * [Формальные тонкости](#%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D0%BE%D0%BD%D0%BA%D0%BE%D1%81%D1%82%D0%B8)
* [Синтаксис `CREATE`](#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81-create)
  * [Типы данных](#%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
  * [Значения по умолчанию](#%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)
  * [Ограничения и ключи](#%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BA%D0%BB%D1%8E%D1%87%D0%B8)
  * [Чего следует избегать](#%D1%87%D0%B5%D0%B3%D0%BE-%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D0%B5%D1%82-%D0%B8%D0%B7%D0%B1%D0%B5%D0%B3%D0%B0%D1%82%D1%8C)
* [Приложение](#%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
  * [Список зарезервированных ключевых слов](#%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B7%D0%B0%D1%80%D0%B5%D0%B7%D0%B5%D1%80%D0%B2%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D1%85-%D1%81%D0%BB%D0%BE%D0%B2)

# SQL: Руководство по стилю

## 1. Предисловие

`Style guide` основан на [Руководстве по стилю SQL](https://www.sqlstyle.guide/ru/) с учетом особенностей наших проектов.

## 2. Основные положения

### 2.1. Базовый Стиль

#### Описание

* **SQL-идентификаторы и SQL-функции**: Только в верхнем регистре.
* **Объекты БД(*tables, columns, alias, view, triggers, procedures*)**: Только в нижнем регистре.
* **Пробелы и отступы**. Можно и нужно использовать пробелы для выравнивания основных ключевых слов по их правому краю. В типографике получающиеся таким образом «[коридоры](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%B8%D0%B4%D0%BE%D1%80_(%D1%82%D0%B8%D0%BF%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0) "Коридоры в типографике")» стараются избегать, в то же время в нашем случае они, напротив, помогают лучше вычленять важные ключевые слова.



#### Причины использования

```
Приведение всего sql-кода к единому виду.
```

#### Примеры

```sql
--Плохо
select pk, role_list, subject, text, notify, users_list, only_main from alerts where   o  nly_main   is not null

 --Хорошо
SELECT a.pk ,
       a.role_list,
       a.subject,
       a.text,
       a.notify, 
       a.users_lis t,
       a.only_main
  FROM alerts a
 WHERE a.only_main IS NOT NULL
```

#### 2.2. Автоматическое форматирование SQL

Т.к. у нас основная БД `Firebird`и работаем мы с ней в `IBExpert`, то как основной инструмент форматирования и будет являться  `IBExpert`. Для удобства есть файл конфигурации.<br>
Инструкция по настройки и форматирование SQL-кода:

* В `IBExpert` Настройка | Настройка форматирования кода..

  ![](image1.png)
* Необходимо импортировать файл конфигурации [sql_formatter.ini](sql_formatter.ini)

  ![](image2.png)
* Открываем редактор
* Вставляем SQL-код
* С помощью горячих клавиш `ALT+F` - код будет отформатирован.

### 2.3. Table and columns alias

#### Описание

* Вне зависимости есть ли join конструкция в запросе или нет, для таблицы присваиваем alias.<br>
* Поля для которые необходимо вывести в результате так же указываем через alias.<br>

**Правила присвоения table alias**:

* Если наименование таблицы состоит из одного слова, допустимо чтобы alias состоял из одной буквы. `Пример 1`
* В случае когда наименование таблицы, составное alias назначается по первым буквам. `Пример 2`
* Если в запросе присутствует `join-конструкция`, наименование таблиц состоят из одного слова и начинается на одну букву, следует: основной таблице оставляем из первой буквы, другой таблице допустимо добавить число. `Пример 3`

**Правила присвоения column alias**: `Пример 4`

* Обязательно через конструкцию `AS`.
* Если наименование столбца, явно не отражает того. что в нем хранится.
* Если два столбца из разных таблиц имеют одинаковое наименование.

#### Причины использования

#### Примеры

```sql

--Пример 1
SELECT u.name
  FROM users u

--Пример 2
SELECT afsp.name
  FROM acceptance_fresh_send_params afsp

--Пример 3
SELECT t.code
  FROM table1 t
  JOIN tabletable t1 ON t1.id = t.t1_id
    
--Пример 4
SELECT a.code AS art_code,
       c.code AS contr_code
  FROM article a
  JOIN op_art ao ON ao.id_art = a.code
  JOIN operation o ON o.id_op = ao.id_op
  JOIN contractor c ON c.id_contr = o.id_contr
  
```

### 2.4. Комментарии

#### Описание

`Комментарии излишни.`

#### Причины использования

В рамках ИС есть большие триггеры в которые заложена чуть ли не вся бизнес-логика.
Без комментариев, могу пожелать удачи разобраться что там происходит

#### Примеры

```sql
  SELECT fs.file_hash -- stored ssdeep hash
    FROM file_system fs
   WHERE fs.file_name = '.vimrc';

/* Updating the file record after writing to the file */
UPDATE file_system fs
   SET fs.file_modified_date = '1980-02-22 13:19:01.00000',
       fs.file_size = 209732
 WHERE fs.file_name = '.vimrc';
```

## 3. Соглашения о наименовании

### 3.1 Общее

* **Убедитесь** в том, что имя уникально и его нет в [списке зарезервированных ключевых слов](#reserved-keyword-reference "Reserved keyword reference").
* **Ограничивайте** длину имени 30 байтами (это 30 символов, если не используется многобайтный набор символов).
* **Начинайте** имена с буквы и **не заканчивайте** их символом подчёркивания.
* **Используйте** в именах только буквы, цифры и символ подчёркивания.
* **Избегайте** нескольких подряд идущих символов подчёркивания.
* **Используйте** символ подчёркивания там, где вы бы поставили пробел в реальной жизни (например, `first name` станет `first_name`).
* **Избегайте** сокращений. Если их всё же нужно использовать, убедитесь в том, что они общепонятны.
* **CamelCase**. Неудобочитаем.
* **Префиксы и [венгерская нотация](https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BD%D0%B3%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F "Wikipedia: Венгерская нотация")**. Префиксы наподобие `sp_` или `tbl_` избыточны.
* **Множественное число**. Лучше использовать более естественно звучащие собирательные понятия. Например, `staff` вместо `employees` или `people` вместо `individuals`.



### 3.2 Таблицы

-- TODO Описать условие наименование таблицы, являющийся переводом наименования инструмента.
-- Для дочерних таблиц условие наименование - префикс основной таблицы, чтобы логически было понятно.

* **Используйте** собирательные имена или, что менее предпочтительно, форму множественного числа. Например, `staff` и `employees` (в порядке убывания предпочтения).
* **Не используйте** описательные префиксы вида `tbl_` и венгерскую нотацию в целом.
* **Не допускайте** совпадений названия таблицы с названием любого из её столбцов.
* По возможности **избегайте** объединения названий двух таблиц для построения таблицы отношений. Например, вместо названия `cars_mechanics` лучше подойдёт `services`.

### 3.3 Столбцы

-- TODO Описать условие наименование столбца, зафиксировать наименования используемых внутри компании, например: 
* ART_CODE
* ART_NAME
* OPNUMBER
* OPSUM
* ....
-- Если это FK то прификс `FK` должен быть в наименовании столбца.

* Названия всегда **давайте** в единственном числе.
* По возможности **не используйте** `id` в качестве первичного идентификатора таблицы.
* **Не создавайте** в таблице столбцов с таким же названием, как у неё самой.
* Названия **всегда пишите** со строчной буквы. Могут быть исключения, например использование имени собственного.

### 3.4 Хранимые процедуры

* Имя **должно** содержать глагол.
* **Не используйте** описательные префиксы вида `sp_` и венгерскую нотацию в целом.

### 3.5 Универсальные суффиксы

Приведённые ниже суффиксы универсальны, что гарантирует простоту понимания значения столбцов из кода SQL.

* `_id` — уникальный идентификатор, например первичный ключ.
* `_status` — флаг или любой статус, например `publication_status`.
* `_total` — общее количество или сумма значений.
* `_num` — поле, содержащее число.
* `_name` — любое имя, например `first_name`.
* `_seq` — непрерывная последовательность значений.
* `_date` — колонка, содержащая дату.
* `_tally` — счётчик.
* `_size` — размер или величина чего-либо, например размер файла.
* `_addr` — физический или абстрактный адрес, например `ip_addr`.

## 4. Синтаксис запросов

### 4.1 Формальные тонкости

* **Используйте** `BETWEEN`, где возможно, вместо нагромождения условий `AND`.
* Таким же образом старайтесь **использовать** `IN()` вместо `OR`.
* **Используйте** `CASE`, если значение должно быть интерпретировано до окончания выполнения запроса. С помощью `CASE` можно также формировать сложные логические структуры.
* По возможности **избегайте** использования `UNION` и временных таблиц.

```sql
  SELECT CASE postcode
  WHEN 'BN1' THEN 'Brighton'
  WHEN 'EH1' THEN 'Edinburgh'
  END AS city
  FROM office_locations
  WHERE country = 'United Kingdom'
  AND opening_time BETWEEN 8 AND 9
  AND postcode IN ('EH1', 'BN1', 'NN1', 'KW1');
```

### 4.2 Синтаксис `CREATE`

При разработке схемы данных важно создавать человекочитаемый код. Убедитесь в том, что объявления столбцов логически структурированы и сгруппированы.

Внутри объявления `CREATE` делайте отступ, равный 4 пробелам.

### 4.3 Типы данных

* По возможности **не используйте** специфичные для той или иной СУБД типы данных. Это может негативно сказаться на переносимости, а также этих типов может не оказаться в старых версиях этих же СУБД.
* Для работы с плавающей точкой **используйте** только `REAL` или `FLOAT`, но где нет необходимости в подобных вычислениях, всегда **используйте** `NUMERIC` и `DECIMAL`. Ошибки округления в операциях с плавающей точкой могут оказаться очень некстати.

### 4.4 Значения по умолчанию

* Значение по умолчанию всегда должно **совпадать** по типу со столбцом. Если, скажем, столбец объявлен как `DECIMAL`, не нужно в качестве умолчания указывать значение типа `INTEGER`.
* Значения по умолчанию должны располагаться **после** объявления типа столбца и **перед** пометкой `NOT NULL`.

### 4.5 Ограничения и ключи

Ограничения и их подмножество, ключи, — важная часть любой структуры базы данных, поэтому важно следовать стандартам их объявления, чтобы избежать трудностей в последующей поддержке написанного.

#### Ключи

Выбор столбцов, которые будут играть роль ключей, должен быть обоснован и предельно выверен, поскольку от них напрямую зависит производительность и целостность данных.

1. Ключ должен быть в какой-то степени уникальным.
2. Должна быть согласованность по типу данных для значения во всей схеме, а также чем ниже вероятность того, что это изменится в будущем, тем лучше.
3. Можно ли проверить значение на соответствие стандарту (например, ISO)?
4. Ключ должен быть как можно проще, чтобы можно было без трудностей использовать составные ключи.

Это своего рода конвенции, которые нужно сформулировать при проектировании базы данных. Если требования впоследствии будут разрастаться, можно и нужно вносить изменения в структуру базы, чтобы поддерживать её в актуальном состоянии.

#### Ограничения

Как только решено, какие ключи должны использоваться, нужно определить их в базе с помощью ограничений наряду с валидацией значений полей.

##### Общее

* У каждой таблицы **должен быть** хотя бы один ключ.
* Ограничениям нужно **присваивать** вразумительные имена. Для `UNIQUE`, `PRIMARY KEY` и `FOREIGN KEY` подобные имена создаются автоматически, поэтому нужно позаботиться об остальных ограничениях.

##### Расположение и порядок

* Первичный ключ должен быть **объявлен** в самом начале, сразу после оператора `CREATE TABLE`.
* Ограничения должны быть **объявлены** строго ниже столбца, с которым они связаны. Расставьте отступы так, чтобы объявление ограничения начиналось после названия столбца.
* В случае ограничений, затрагивающих несколько столбцов, старайтесь **объявлять** их как можно ближе к описанию последнего из них. В крайнем случае объявляйте ограничение в конце тела `CREATE TABLE`.
* Ограничения целостности уровня таблицы должны **располагаться** в конце.
* **Используйте** алфавитный порядок там, где `ON DELETE` предшествует `ON UPDATE`.
* Внутри запроса можно **выравнивать** каждый уровень по-своему. Например, можно добавить отступы после названия столбцов, чтобы типы данных начинались с одной позиции, а затем ещё добавить отступов в нужном количестве, чтобы все объявления `NOT NULL` тоже были выровнены по левому краю. Подобное форматирование позволит быстрее ориентироваться в коде.

##### Валидация

* **Используйте** `LIKE` и `SIMILAR TO` для обеспечения целостности строк с известным форматом.
* Если диапазон числовых значений для столбца известен, **используйте** `CHECK()` для предотвращения внесения в базу некорректных данных или скрытого отсечения части значения слишком больших данных. Обычно проверка делается на то, что значение больше нуля.
* `CHECK()` должен быть **объявлен** как отдельное ограничение для упрощения последующей отладки.

##### Пример

```sql
CREATE TABLE staff (
    PRIMARY KEY (staff_num),
    staff_num      INT(5)       NOT NULL,
    first_name     VARCHAR(100) NOT NULL,
    pens_in_drawer INT(2)       NOT NULL,
                   CONSTRAINT pens_in_drawer_range
                   CHECK(pens_in_drawer BETWEEN 1 AND 99)
);
```



### Чего следует избегать

* **Не применяйте** объектно-ориентированные принципы, поскольку они далеко не всегда оптимально ложатся на реляционную модель баз данных.
* **Не разносите** по разным столбцам значения и единицы измерения. Нужно создавать столбцы так, чтобы единицы измерения были чем-то самим собой разумеющимся. Для проверки корректности вставляемых в столбец данных используйте `CHECK()`.
* **Избегайте** паттерна [EAV (Entity Attribute Value)](https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model "Wikipedia: Entity–attribute–value model"). Вместо него используйте специальные продукты, предназначенные для работы с неструктурированными данными.
* **Не разбивайте** данные, логически принадлежащие одной таблице, по разным таблицам на основании условностей, например архивации по времени или географическим атрибутам. Впоследствии для работы с несколькими подобными таблицам придётся часто использовать `UNION` вместо простых запросов к одной таблице.

## Приложение

### Список зарезервированных ключевых слов

[Список зарезервированных ключевых слов ANSI SQL](https://translated.turbopages.org/proxy_u/en-ru.ru.bd500fa3-64ae9d33-54a7a2a9-74722d776562/https/en.wikipedia.org/wiki/List_of_SQL_reserved_words)
